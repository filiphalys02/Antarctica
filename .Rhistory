stepi <- 0
id_daty <- 0
while (i < 50) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < minimalny_zasieg] <- minimalny_zasieg
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
saveGIF({
i <- 1
prog_bar <- txtProgressBar(min = 0, max = 50, style = 3)
stepi <- 0
id_daty <- 0
while (i < 50) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
dane <- read.csv("daily_ice_edge.csv")
daty <- seq(as.Date(min(dane$Date)), as.Date(max(dane$Date)), by = "day")
dane <- read.csv("daily_ice_edge.csv")
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy daty od pierwszej do ostatniej w danych
daty <- seq(min(dane$Date), max(dane$Date), by = "day")
dane <- read.csv("daily_ice_edge.csv")
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy daty od pierwszej do ostatniej w danych
daty <- seq(min(dane$Date), max(dane$Date), by = "day")
dane <- read.csv("daily_ice_edge.csv")
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy daty od pierwszej do ostatniej w danych
min_date <- min(dane$Date)
max_date <- max(dane$Date)
daty <- seq.Date(from = min_date, to = max_date, by = "day")
dane <- read.csv("daily_ice_edge.csv")
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Łączymy dane brakujące z istniejącymi danymi
dane_kompletne <- merge(dane, data.frame(Date = daty_brakujace), by = "Date", all = TRUE)
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:1000, ]
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Łączymy dane brakujące z istniejącymi danymi
dane_kompletne <- merge(dane, data.frame(Date = daty_brakujace), by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date), ]
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
dane <- read.csv("daily_ice_edge.csv")
# Ograniczamy dane do pierwszych 1000 wierszy
dane <- dane[1:200,]
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Łączymy dane brakujące z istniejącymi danymi
dane_kompletne <- merge(dane, data.frame(Date = daty_brakujace), by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date), ]
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
dane <- dane[1:1000, ]
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Łączymy dane brakujące z istniejącymi danymi
dane_kompletne <- data.frame(Date = daty_brakujace)
dane_kompletne <- merge(dane_kompletne, dane, by = "Date", all.x = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date), ]
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
View(dane_kompletne)
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Tworzymy ramkę danych z brakującymi datami
dane_brakujace <- data.frame(Date = daty_brakujace)
# Łączymy dane brakujące z oryginalnymi danymi
dane_kompletne <- merge(dane_brakujace, dane, by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date),]
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Tworzymy ramkę danych z brakującymi datami
dane_brakujace <- data.frame(Date = daty_brakujace)
# Łączymy dane brakujące z oryginalnymi danymi
dane_kompletne <- merge(dane_brakujace, dane, by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date),]
# Sprawdzamy, czy wszystkie daty zostały dodane poprawnie
print(head(dane_kompletne))
View(dane_kompletne)
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
brakujace_extent <- sum(is.na(dane_kompletne$Extent))
if (brakujace_extent > 0) {
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
}
View(dane_kompletne)
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
# Konwertujemy kolumnę Date na obiekty daty
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Tworzymy ramkę danych z brakującymi datami
dane_brakujace <- data.frame(Date = daty_brakujace)
# Łączymy dane brakujące z oryginalnymi danymi
dane_kompletne <- merge(dane_brakujace, dane, by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date),]
# Obliczamy średnią zasięgu lodu pomiędzy dniem poprzednim a następnym
for (i in 2:(nrow(dane_kompletne) - 1)) {
if (is.na(dane_kompletne$Extent[i])) {
dane_kompletne$Extent[i] <- mean(c(dane_kompletne$Extent[i - 1], dane_kompletne$Extent[i + 1]), na.rm = TRUE)
}
}
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Tworzymy ramkę danych z brakującymi datami
dane_brakujace <- data.frame(Date = daty_brakujace)
# Łączymy dane brakujące z oryginalnymi danymi
dane_kompletne <- merge(dane_brakujace, dane, by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date),]
# Uzupełniamy brakujące wartości w kolumnie Extent przez interpolację
dane_kompletne$Extent <- na.approx(dane_kompletne$Extent)
# Uzupełniamy brakujące wartości w kolumnie Extent przez interpolację
dane_kompletne$Extent <- approx(x = seq_along(dane_kompletne$Extent), y = dane_kompletne$Extent, method = "linear", na.rm = FALSE)$y
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
# Pobieramy daty z kolumny Date
daty <- dane$Date
# Tworzymy wektor indeksów brakujących dat
brakujace_daty <- setdiff(dni, as.integer(difftime(daty, min(daty), units = "days")) + 1)
# Tworzymy daty brakujących dni
daty_brakujace <- min(daty) + as.difftime(sort(brakujace_daty) - 1, units = "days")
# Tworzymy ramkę danych z brakującymi datami
dane_brakujace <- data.frame(Date = daty_brakujace)
# Łączymy dane brakujące z oryginalnymi danymi
dane_kompletne <- merge(dane_brakujace, dane, by = "Date", all = TRUE)
# Sortujemy dane po dacie
dane_kompletne <- dane_kompletne[order(dane_kompletne$Date),]
# Uzupełniamy brakujące wartości w kolumnie Extent przez interpolację
library(zoo)
dane_kompletne$Extent <- na.approx(dane_kompletne$Extent, na.rm = FALSE)
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
# Tworzymy sekwencję dni jako liczby całkowite od pierwszego do ostatniego wiersza danych
dni <- seq.int(from = 1, to = nrow(dane), by = 1)
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y")
View(dane)
dane <- read.csv("daily_ice_edge.csv")
View(dane)
dane <- read.csv("daily_ice_edge.csv")
dane <- dane[1:20,]
dane$Date <- as.Date(dane$Date, format = "%d-%b-%Y", locale = "C")
View(dane)
library(animation)
library(ggplot2)
library(matrixStats)
dane <- read.csv("daily_ice_edge.csv")
rozmiar_danych <- dim(dane)
liczba_wierszy <- rozmiar_danych[1]
liczba_kolumn <- rozmiar_danych[2]
liczba_kolumn <- liczba_kolumn - 1
dane_bezdat <- as.matrix(dane[1:liczba_wierszy, 2:liczba_kolumn])
granica_lodu_min <- colMins(dane_bezdat)
katy <- c(0:359)
granica_lodu_min_dataframe <- data.frame(lon = katy, lat = granica_lodu_min)
ggplot(granica_lodu_min_dataframe, aes(x=lon, y=lat, col='Minimalny zasieg')) +
geom_path() +
coord_polar() +
labs(x='', y='', title='Minimalny zasieg lodu') +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90,-60)
minimalny_zasieg <- min(granica_lodu_min)  # Obliczenie minimalnego zasięgu
saveGIF({
i <- 1
prog_bar <- txtProgressBar(min = 0, max = 50, style = 3)
stepi <- 0
id_daty <- 0
while (i < 50) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
saveGIF({
i <- 1
prog_bar <- txtProgressBar(min = 0, max = 500, style = 3)
stepi <- 0
id_daty <- 0
while (i < 500) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
saveGIF({
i <- 1
prog_bar <- txtProgressBar(min = 0, max = 500, style = 3)
stepi <- 0
id_daty <- 0
while (i < 500) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
saveGIF({
i <- liczba_wierszy - 50
prog_bar <- txtProgressBar(min = 0, max = 50, style = 3)
stepi <- 0
id_daty <- 0
while (i < liczba_wierszy) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
View(dane)
saveGIF({
i <- liczba_wierszy - 50
prog_bar <- txtProgressBar(min = 0, max = 50, style = 3)
stepi <- 0
id_daty <- liczba_wierszy - 50
while (i < liczba_wierszy) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
saveGIF({
i <- liczba_wierszy - 500
prog_bar <- txtProgressBar(min = 0, max = 500, style = 3)
stepi <- 0
id_daty <- liczba_wierszy - 500
while (i < liczba_wierszy) {
granica_lodu <- data.frame(lon = katy, lat = dane_bezdat[i,])
long <- cos(2 * pi * granica_lodu$lon / 360)
latt <- sin(2 * pi * granica_lodu$lat / 180)
lm <- lm(granica_lodu$lat ~ long + latt)
predict <- predict(lm, newdata = data.frame(granica_lodu$lon))
granica_lodu$predict <- predict
granica_lodu_mat <- data.frame(lon = katy, lat = predict)
# Sprawdzenie czy wyinterpolowany model jest mniejszy od minimalnego zasięgu
granica_lodu_mat$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat] <- granica_lodu_min_dataframe$lat[granica_lodu_mat$lat < granica_lodu_min_dataframe$lat]
x <- ggplot(granica_lodu, aes(x = lon, y = lat, col = "Rzeczywisty zasieg")) +
geom_path() +
geom_line(data = granica_lodu_mat, aes(x = lon, y = lat, col = "Model matematyczny zasieg")) +
geom_line(data = granica_lodu_min_dataframe, aes(x = lon, y = lat, col = "Minimalny zasieg")) +
coord_polar() +
labs(x = '', y = '', title = 'Minimalny zasieg lodu') +
scale_x_continuous(breaks = seq(0, 360, 45), labels = c("0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°", "360°")) +
ylim(-90, -45) +
ggtitle(dane[id_daty, 1]) +
labs(color = 'Wykresy:')
print(x)
i <- i + 1
id_daty <- id_daty + 1
stepi <- stepi + 1
setTxtProgressBar(prog_bar, stepi)
}
}, interval = 0.01)
